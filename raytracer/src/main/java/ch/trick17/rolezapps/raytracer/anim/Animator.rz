package ch.trick17.rolezapps.raytracer.anim

import rolez.util.ArrayList
import rolez.util.Random
import ch.trick17.rolezapps.raytracer.Raytracer
import ch.trick17.rolezapps.raytracer.util.VideoWriter
import ch.trick17.rolezapps.raytracer.util.ImageWriter

class Animator {
    
    val random: readwrite Random = new Random
    
    val raytracer: readwrite Raytracer
    val scene: readwrite AnimatedScene
    val writer: readwrite VideoWriter
    
    var frame: int
    
    new(raytracer: readwrite Raytracer, scene: readwrite AnimatedScene, writer: readwrite VideoWriter) {
        this.raytracer = raytracer;
        this.scene = scene;
        this.writer = writer;
    }
    
    def readonly time: double { return this.frame as double / this.writer.framerate; }
    
    def readonly frames: int  {
        return the Math.ceil(this.scene.length * this.writer.framerate) as int;
    }
    
    def readwrite render: {
        this.frame = 0;
        this.raytracer.scene = this.scene;
        
        val image = new Array[readwrite Array[int]](this.writer.height);
        for(var i = 0; i < image.length; i += 1)
            image.set(i, new Array[int](this.writer.width));
        
        while(this.frame < this.frames) {
            this.raytracer.render(image);
            this.writer.writeFrame(image);
            
            this.frame += 1;
            this.animate;
            the System.out.println("Frame " + this.frame + "/" + this.frames);
        }
        this.writer.close;
    }
    
    def readwrite animate: {
        for(var i = 0; i < this.scene.animations.size; i += 1) {
            val animation = this.scene.animations.get(i);
            if(animation.begun(this.time) && !animation.finished(this.time))
                animation.animationStep(this.time, this.writer.framerate);
        }
    }
}