package ch.trick17.rolezapps.raytracer

class Animation {
    /* To be implemented by subclasses */
    def readwrite    begun(time: double): boolean { return false; }
    def readwrite finished(time: double): boolean { return false; }
    def readwrite animationStep(time: double, framerate: int): {}
}

class SimpleAnimation extends Animation {
    
    val duration: pure Duration
    
    var    begun: boolean = false
    var finished: boolean = false
    
    new(duration: pure Duration) {
        this.duration = duration;
    }
    
    override readwrite begun(time: double): boolean {
        if(!this.begun && time >= this.duration.begin) {
            this.begun = true;
            this.onBegin;
        }
        return this.begun;
    }
    
    override readwrite finished(time: double): boolean {
        if(!this.finished && time >= this.duration.end) {
            this.finished = true;
            this.onFinish;
        }
        return this.finished;
    }
    
    /* May be overridden by subclasses */
    def readwrite onBegin : {}
    def readwrite onFinish: {}
}

class AnimationGroup extends Animation {
    
    val animations: readwrite Array[readwrite Animation]
    var firstBegun  : boolean = false
    var lastFinished: boolean = false
    
    new(animations: readwrite Array[readwrite Animation]) {
        this.animations = animations;
    }
    
    override readwrite begun(time: double): boolean {
        var oneBegun = false;
        for(var i = 0; i < this.animations.length; i += 1) {
            if(this.animations.get(i).begun(time))
                oneBegun = true;
        }
        if(!this.firstBegun && oneBegun) {
            this.firstBegun = true;
            this.onFirstBegin;
        }
        return oneBegun;
    }
    
    override readwrite finished(time: double): boolean {
        var allFinished = true;
        for(var i = 0; i < this.animations.length; i += 1) {
            if(!this.animations.get(i).finished(time))
                allFinished = false;
        }
        if(!this.lastFinished && allFinished) {
            this.lastFinished = true;
            this.onLastFinish;
        }
        return allFinished;
    }
    
    override readwrite animationStep(time: double, framerate: int): {
        for(var i = 0; i < this.animations.length; i += 1) {
            val animation = this.animations.get(i);
            if(animation.begun(time) && !animation.finished(time))
                animation.animationStep(time, framerate);
        }
    }
    
    /* May be overridden by subclasses */
    def readwrite onFirstBegin: {}
    def readwrite onLastFinish: {}
}

class LinearMovement extends SimpleAnimation {
    
    val obj: readwrite Moveable
    val deltaPerS: pure Vector3D
    
    new(duration: pure Duration, obj: readwrite Moveable, deltaPerS: pure Vector3D) {
        super(duration);
        this.obj = obj;
        this.deltaPerS = deltaPerS;
    }
    
    override readwrite animationStep(time: double, framerate: int): {
        this.obj.move(this.deltaPerS.scale(1.0 / framerate));
    }
}

class CircularMovement extends SimpleAnimation {
    
    val obj: readwrite Moveable
    val u1: pure Vector3D
    val u2: pure Vector3D
    val thetaPerS: double
    
    new(duration: pure Duration, obj: readwrite Moveable, toCenter: pure Vector3D, up: pure Vector3D,
            thetaPerS: double) {
        super(duration);
        this.obj = obj;
        this.u1 = toCenter.negate;
        this.u2 = up.cross(this.u1).normalize.scale(this.u1.length);
        this.thetaPerS = thetaPerS;
    }
    
    override readwrite animationStep(time: double, framerate: int): {
        val oldTheta = (time - this.duration.begin - 1.0 / framerate) * this.thetaPerS;
        val newTheta = (time - this.duration.begin) * this.thetaPerS;
        val delta = this.u1.scale(the Math.cos(newTheta) - the Math.cos(oldTheta))
                .plus(this.u2.scale(the Math.sin(newTheta) - the Math.sin(oldTheta)));
        this.obj.move(delta);
    }
}

class BrightnessChange extends SimpleAnimation {
    
    val light: readwrite Light
    val changePerS: double
    
    new(duration: pure Duration, light: readwrite Light, changePerS: double) {
        super(duration);
        this.light = light;
        this.changePerS = changePerS;
    }
    
    override readwrite animationStep(time: double, f: int): {
        this.light.brightness = the Math.max(0.0, this.light.brightness + this.changePerS / f);
    }
}

class AmbientLightChange extends SimpleAnimation {
    
    val scene: readwrite Scene
    val changePerS: double
    
    new(duration: pure Duration, scene: readwrite Scene, changePerS: double) {
        super(duration);
        this.scene = scene;
        this.changePerS = changePerS;
    }
    
    override readwrite animationStep(time: double, framerate: int): {
        this.scene.ambientLight += this.changePerS / framerate;
    }
}

class BackgroundChange extends SimpleAnimation {
    
    val scene: readwrite Scene
    val rChangePerS: double
    val gChangePerS: double
    val bChangePerS: double
    
    new(duration: pure Duration, scene: readwrite Scene,
            rChangePerS: double, gChangePerS: double, bChangePerS: double) {
        super(duration);
        this.scene = scene;
        this.rChangePerS = rChangePerS;
        this.gChangePerS = gChangePerS;
        this.bChangePerS = bChangePerS;
    }
    
    override readwrite animationStep(time: double, f: int): {
        val bg = this.scene.background;
        this.scene.background = new Color(
            bg.r + this.rChangePerS / f,
            bg.g + this.gChangePerS / f,
            bg.b + this.bChangePerS / f
        );
    }
}