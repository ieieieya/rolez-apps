package ch.trick17.rolezapps.kmeans

import rolez.util.Random
import rolez.util.Scanner
import rolez.util.StopWatch

class KMeans {
    
    val dim: int
    val clusters: int
    val numTasks: int
    
    new {
        this.dim = 10;
        this.clusters = 10;
        this.numTasks = 8;
    }
    
    new(dim: int, clusters: int, numTasks: int) {
        this.dim = dim;
        this.clusters = clusters;
        this.numTasks = numTasks;
    }
    
    def pure createDataSet(n: int): readwrite Array[pure Vector[double]] {
        val random = new Random;
        val dataSet = new Array[pure Vector[double]](n);
        for(var i = 0; i < n; i++)
            dataSet.set(i, this.newRandomVector(random));
        return dataSet;
    }
    
    def pure newRandomVector(random: readwrite Random): pure Vector[double] {
        val vec = new VectorBuilder[double](this.dim);
        for(var d = 0; d < this.dim; d++)
            vec.set(d, random.nextDouble);
        return vec.build;
    }
    
    def pure kMeans(dataSet: readonly Array[pure Vector[double]], maxIterations: int):
            readwrite Array[pure Vector[double]] {
        return null;
    }
}

class KMeansRolez extends KMeans {
    
    new {}
    
    new(dim: int, clusters: int, numTasks: int) {
        super(dim, clusters, numTasks);
    }
    
    override pure kMeans(dataSet: readonly Array[pure Vector[double]], maxIterations: int):
            readwrite Array[pure Vector[double]] {
        /* Initialization */
        val random = new Random;
        val centroids = new Array[pure Vector[double]](this.clusters);
        for(var i = 0; i < this.clusters; i++)
            centroids.set(i, this.newRandomVector(random));
        
        val assignments = new Array[int](dataSet.length);
        
        /* Computation */
        var iterations = 0;
        var changed = true;
        while(changed && iterations < maxIterations) {
            /* Assignment step */
            val dataParts = dataSet.partition(the ContiguousPartitioner, this.numTasks);
            val assignParts = assignments.partition(the ContiguousPartitioner, this.numTasks);
            val tasks = new Array[pure Task[boolean]](this.numTasks);
            
            for(var i = 0; i < tasks.length; i++)
                tasks.set(i, this start assign(dataParts.get(i), centroids, assignParts.get(i)));
            
            changed = false;
            for(var i = 0; i < tasks.length; i++)
                changed |= tasks.get(i).get;
            
            /* Update step */
            val newCentroids = new Array[readwrite VectorBuilder[double]](this.clusters);
            for(var i = 0; i < newCentroids.length; i++)
                newCentroids.set(i, new VectorBuilder[double](this.dim));
            val counts = new Array[int](this.clusters);
            
            for(var i = 0; i < dataSet.length; i++) {
                val vector = dataSet.get(i);
                val centroidIndex = assignments.get(i);
                val centroid = newCentroids.get(centroidIndex);
                for(var d = 0; d < this.dim; d++)
                    centroid.set(d, centroid.get(d) + vector.get(d));
                counts.set(centroidIndex, counts.get(centroidIndex) + 1);
            }
            
            for(var i = 0; i < centroids.length; i++) {
                val centroid = newCentroids.get(i);
                val count = counts.get(i);
                for(var d = 0; d < this.dim; d++)
                    centroid.set(d, centroid.get(d) / count);
                centroids.set(i, centroid.build);
            }
            iterations++;
        }
        return centroids;
    }
    
    task pure assign(dataSet: readonly Slice[pure Vector[double]],
            centroids: readonly Array[pure Vector[double]],
            assignments: readwrite Slice[int]): boolean {
        var changed = false;
        for(var i = dataSet.range.begin; i < dataSet.range.end; i += dataSet.range.step) {
            var min = the Double.POSITIVE_INFINITY;
            var minIndex = -1;
            for(var c = 0; c < centroids.length; c++) {
                val distance2 = this.distance2(dataSet.get(i), centroids.get(c));
                if(distance2 < min) {
                    min = distance2;
                    minIndex = c;
                }
            }
            if(minIndex != assignments.get(i)) {
                changed = true;
                assignments.set(i, minIndex);
            }
        }
        return changed;
    }
    
    def pure distance2(v1: pure Vector[double], v2: pure Vector[double]): double {
        var sum = 0.0;
        for(var d = 0; d < this.dim; d++) {
            val diff = v1.get(d) - v2.get(d);
            sum += diff * diff;
        }
        return sum;
    }
    
    task pure main(args: readonly Array[pure String]): {
        val n = the Int.parseInt(args.get(0));
        val maxIterations = the Int.parseInt(args.get(1));
        val repetitions = 100;
        val watch = new StopWatch;
        
        val dataSets = new Array[readwrite Array[pure Vector[double]]](repetitions);
        for(var i = 0; i < repetitions; i++)
            dataSets.set(i, this.createDataSet(n));
        
        the System.out.println("Press Enter to start");
        new Scanner(the System.in).nextLine;
        for(var i = 0; i < repetitions; i++) {
            watch.go;
            this.kMeans(dataSets.get(i), maxIterations);
            the System.out.println(watch.get);
        }
    }
}