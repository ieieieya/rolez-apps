package ch.trick17.rolezapps.kmeans

import rolez.util.Random
import rolez.util.Scanner
import rolez.util.StopWatch

class KMeans {
    
    val dim: int
    val clusters: int
    val numTasks: int
    
    new {
        this.dim = 10;
        this.clusters = 10;
        this.numTasks = 8;
    }
    
    new(dim: int, clusters: int, numTasks: int) {
        this.dim = dim;
        this.clusters = clusters;
        this.numTasks = numTasks;
    }
    
    def pure createDataSet(n: int): readwrite Array[readonly Array[double]] {
        val random = new Random;
        val dataSet = new Array[readonly Array[double]](n);
        for(var i = 0; i < n; i += 1)
            dataSet.set(i, this.newRandomVector(random));
        return dataSet;
    }
    
    def pure kMeans(dataSet: readwrite Array[readonly Array[double]]): readwrite Array[readonly Array[double]] {
        /* Initialization */
        val random = new Random;
        val centroids = new Array[readonly Array[double]](this.clusters);
        for(var i = 0; i < this.clusters; i += 1)
            centroids.set(i, this.newRandomVector(random));
        
        val assignments = new Array[int](dataSet.length);
        
        /* Computation */
        var changed = true;
        while(changed) {
            /* Assignment step */
            // TODO: Why are type declarations required?
            val dataParts: readonly Array[readwrite Slice[readonly Array[double]]] = dataSet.partition(the ContiguousPartitioner, this.numTasks);
            val assignParts: readonly Array[readwrite Slice[int]] = assignments.partition(the ContiguousPartitioner, this.numTasks);
            val tasks = new Array[pure Task[boolean]](this.numTasks);
            
            for(var i = 0; i < tasks.length; i+= 1)
                tasks.set(i, this start assign(dataParts.get(i), centroids, assignParts.get(i)));
            
            changed = false;
            for(var i = 0; i < tasks.length; i += 1)
                changed |= tasks.get(i).get;
            
            /* Update step */
            val newCentroids = new Array[readwrite Array[double]](this.clusters);
            for(var i = 0; i < newCentroids.length; i += 1)
                newCentroids.set(i, new Array[double](this.dim));
            val counts = new Array[int](this.clusters);
            
            for(var i = 0; i < dataSet.length; i += 1) {
                val vector = dataSet.get(i);
                val centroidIndex = assignments.get(i);
                val centroid = newCentroids.get(centroidIndex);
                for(var d = 0; d < this.dim; d += 1)
                    centroid.set(d, centroid.get(d) + vector.get(d));
                counts.set(centroidIndex, counts.get(centroidIndex) + 1);
            }
            
            for(var i = 0; i < centroids.length; i += 1) {
                val centroid = newCentroids.get(i);
                val count = counts.get(i);
                for(var d = 0; d < this.dim; d += 1)
                    centroid.set(d, centroid.get(d) / count);
                centroids.set(i, centroid);
            }
        }
        
        return centroids;
    }
    
    task pure assign(dataSet: readonly Slice[readonly Array[double]],
            centroids: readonly Array[readonly Array[double]],
            assignments: readwrite Slice[int]): boolean {
        var changed = false;
        for(var i = dataSet.range.begin; i < dataSet.range.end; i += dataSet.range.step) {
            var min = the Double.POSITIVE_INFINITY;
            var minIndex = -1;
            for(var c = 0; c < centroids.length; c += 1) {
                val distance2 = this.distance2(dataSet.get(i), centroids.get(c));
                if(distance2 < min) {
                    min = distance2;
                    minIndex = c;
                }
            }
            if(minIndex != assignments.get(i)) {
                changed = true;
                assignments.set(i, minIndex);
            }
        }
        return changed;
    }
    
    def pure distance2(v1: readonly Array[double], v2: readonly Array[double]): double {
        var sum = 0.0;
        for(var d = 0; d < this.dim; d += 1) {
            val diff = v1.get(d) - v2.get(d);
            sum += diff * diff;
        }
        return sum;
    }
    
    def pure newRandomVector(random: readwrite Random): readonly Array[double] {
        val vec = new Array[double](this.dim);
        for(var d = 0; d < this.dim; d += 1)
            vec.set(d, random.nextDouble);
        return vec;
    }
    
    task pure main(args: readonly Array[pure String]): {
        val n = the Int.parseInt(args.get(0));
        val iterations = 10;
        val watch = new StopWatch;
        
        val dataSets = new Array[readwrite Array[readonly Array[double]]](iterations);
        for(var i = 0; i < iterations; i += 1)
            dataSets.set(i, this.createDataSet(n));
        
        the System.out.println("Press Enter to start");
        new Scanner(the System.in).nextLine;
        for(var i = 0; i < iterations; i += 1) {
            watch.go;
            this.kMeans(dataSets.get(i));
            the System.out.println(watch.get);
        }
    }
}