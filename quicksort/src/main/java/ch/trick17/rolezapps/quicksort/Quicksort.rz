package ch.trick17.rolezapps.quicksort

import rolez.util.Random
import rolez.util.StopWatch

class Quicksort {
    val tasks: int
    
    new {
        this.tasks = 2; // TODO: Use number of (real) CPUs
    }
    
    new(tasks: int) {
        this.tasks = tasks;
    }
    
    def pure maxLevel: int { return this.log2(this.tasks); }
    
    def pure log2(i: int): int {
        // TODO: Move this to Math once non-mapped methods are supported for mapped singletons
        if(i < 1) return -1;
        else return 31 - the Int.numberOfLeadingZeros(i);
    }
    
    task pure main(args: readonly Array[pure String]): {
        val n = the Int.parseInt(args.get(0));
        val array = this.shuffledInts(n);
        
        val watch = new StopWatch.go;
        val sortTask = this start sort(array);
        
        sortTask.get;
        the System.out.println(watch.get);
    }
    
    def pure shuffledInts(n: int): readwrite Array[int] {
        val array = new Array[int](n);
        for(var i = 0; i < n; i += 1)
            array.set(i, i);
        
        val random = new Random;
        for(var i = n - 1; i > 0; i -= 1) {
            val index: int = random.nextInt(i + 1);
            
            val t = array.get(index);
            array.set(index, array.get(i));
            array.set(i, t);
        }
        return array;
    }
    
    task pure sort(s: readwrite Array[int]): {
        this.doSort(s, s.range.begin, s.range.end, 0);
    }
    
    task pure doSort(s: readwrite Slice[int], begin: int, end: int, level: int): {
        val pivot = this.pivot(s, begin, end);
        var  left = begin;
        var right = end - 1;
        while(left <= right) {
            while(s.get( left) < pivot)  left += 1;
            while(s.get(right) > pivot) right -= 1;
            if(left <= right) {
                val temp = s.get(left);
                s.set(left, s.get(right));
                s.set(right, temp);
                left += 1;
                right -= 1;
            }
        }
        
        if(begin < right) {
            if(level < this.maxLevel)
                this start doSort(s.slice(begin, right + 1, 1), begin, right + 1, level + 1);
            else
                this.doSort(s, begin, right + 1, level + 1);
        }
        if(left < end)
            this.doSort(s, left, end, level + 1);
    }
    
    def pure pivot(s: readonly Slice[int], begin: int, end: int): int {
        // TODO: Use "ninther" for large enough slices
        val l = s.get(begin);
        val m = s.get(begin + (end - begin) / 2);
        val r = s.get(end - 1);
        if(l < m) {
            if(m < r) return m;
            else if(l < r) return l;
            else return r;
        }
        else { // m <= l
            if(l < r) return l;
            else if(m < r) return r;
            else return m;
        }
    }
}