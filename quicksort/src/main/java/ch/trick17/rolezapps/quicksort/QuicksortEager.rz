package ch.trick17.rolezapps.quicksort

import rolez.util.Random

// pretty much copy of RolezQuicksort, simply used parallel construct instead of normal task start
class QuicksortRolezEager extends Quicksort {
    
    new{}
    
    new(maxLevel: int) {
        super(maxLevel);
    }
    
    override pure sort(a: readwrite Array[int]): {
        this.doSort(a, 0, a.length, 0);
    }
    
    task pure doSort(s: readwrite Slice[int], begin: int, end: int, level: int): {
        val pivot = this.pivot(s, begin, end);
        var  left = begin;
        var right = end - 1;
        while(left <= right) {
            while(s.get( left) < pivot)  left++;
            while(s.get(right) > pivot) right--;
            if(left <= right) {
                val temp = s.get(left);
                s.set(left, s.get(right));
                s.set(right, temp);
                left++;
                right--;
            }
        }
        
        val sortLeft  = begin < right;
        val sortRight = left  < end - 1;
        
        // TODO: Switch to optimized version when maxLevel is reached
        if(level < this.maxLevel) {
            // create slices and do in parallel if both need doing
            if(sortLeft && sortRight) {
            	parallel
            		this.doSort(s.slice(begin, right + 1), begin, right + 1, level + 1);
            	and
            		this.doSort(s.slice( left,       end),  left,       end, level + 1);
            } else if(sortLeft) {
            	this.doSort(s.slice(begin, right + 1), begin, right + 1, level + 1);
            } else if(sortRight) {
            	this.doSort(s.slice( left,       end),  left,       end, level + 1);
            }
        }
        else {
            if(sortLeft)  this.doSort(s, begin, right + 1, level + 1);
            if(sortRight) this.doSort(s,  left,       end, level + 1);
        }
    }
    
    def pure pivot(s: readonly Slice[int], begin: int, end: int): int {
        // TODO: Use "ninther" for large enough slices
        val l = s.get(begin);
        val m = s.get(begin + (end - begin) / 2);
        val r = s.get(end - 1);
        if(l < m) {
            if(m < r) return m;
            else if(l < r) return l;
            else return r;
        }
        else { // m <= l
            if(l < r) return l;
            else if(m < r) return r;
            else return m;
        }
    }
}
