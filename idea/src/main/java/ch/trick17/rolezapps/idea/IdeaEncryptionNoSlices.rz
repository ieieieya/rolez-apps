package ch.trick17.rolezapps.idea

import rolez.util.Random
import rolez.util.Arrays
import rolez.util.Scanner
import rolez.util.StopWatch

class IdeaEncryptionRolezNoSlices extends IdeaEncryptionRolez {
    
    new(size: int, tasks: int) {
        super(size, tasks);
    }
    
    override readwrite run: {
        val ranges = new BlockPartitioner(8).partition(this.plain.range, this.tasks);
        
        val privEncrypted = new Array[readwrite Array[byte]](this.tasks);
        val privDecrypted = new Array[readwrite Array[byte]](this.tasks);
        for(var i = 0; i < this.tasks; i++) {
            privEncrypted.set(i, new Array[byte](ranges.get(i).size));
            privDecrypted.set(i, new Array[byte](ranges.get(i).size));
        }
        
        // encrypt
        for(var i = 0; i < this.tasks; i++)
            this start encryptDecrypt(this.plain, privEncrypted.get(i), ranges.get(i), this.encryptKey);
        this.encrypted = this.merge(privEncrypted, ranges);
        
        // decrypt
        for(var i = 0; i < this.tasks; i++)
            this start encryptDecrypt(this.encrypted, privDecrypted.get(i), ranges.get(i), this.decryptKey);
        this.decrypted = this.merge(privDecrypted, ranges);
    }
    
    task pure encryptDecrypt(src: readonly Array[byte], dst: readwrite Array[byte],
            range: pure SliceRange, key: pure Vector[int]): {
        val xFF = 255;
        val xFFFF = 65535;
        val x10001L = 65537L;

        var iSrc = range.begin;        
        var iDst = 0;
        for(var i = range.begin; i < range.end; i += 8) {
            // Load eight plain1 bytes as four 16-bit "unsigned" integers.
            // Masking with 0xFF prevents sign extension with cast to int.
            
            var x1 = src.get(iSrc++) & xFF; // Build 16-bit x1 from 2 bytes,
            x1 = x1 | (src.get(iSrc++) & xFF) << 8; // assuming low-order byte first.
            var x2 = src.get(iSrc++) & xFF;
            x2 = x2 | (src.get(iSrc++) & xFF) << 8;
            var x3 = src.get(iSrc++) & xFF;
            x3 = x3 | (src.get(iSrc++) & xFF) << 8;
            var x4 = src.get(iSrc++) & xFF;
            x4 = x4 | (src.get(iSrc++) & xFF) << 8;
            
            var iKey = 0;
            for(var round = 0; round < 8; round++) {
                // 1) Multiply (modulo 0x10001), 1st text sub-block
                // with 1st key sub-block.
                x1 = (x1 as long * key.get(iKey++) % x10001L & xFFFF) as int;
                
                // 2) Add (modulo 0x10000), 2nd text sub-block
                // with 2nd key sub-block.
                x2 = x2 + key.get(iKey++) & xFFFF;
                
                // 3) Add (modulo 0x10000), 3rd text sub-block
                // with 3rd key sub-block.
                x3 = x3 + key.get(iKey++) & xFFFF;
                
                // 4) Multiply (modulo 0x10001), 4th text sub-block
                // with 4th key sub-block.
                x4 = (x4 as long * key.get(iKey++) % x10001L & xFFFF) as int;
                
                // 5) XOR results from steps 1 and 3.
                var t0 = x1 ^ x3;
                
                // 6) XOR results from steps 2 and 4.
                // Included in step 8.
                
                // 7) Multiply (modulo 0x10001), result of step 5
                // with 5th key sub-block.
                t0 = (t0 as long * key.get(iKey++) % x10001L & xFFFF) as int;
                
                // 8) Add (modulo 0x10000), results of steps 6 and 7.
                var t1 = t0 + (x2 ^ x4) & xFFFF;
                
                // 9) Multiply (modulo 0x10001), result of step 8
                // with 6th key sub-block.
                t1 = (t1 as long * key.get(iKey++) % x10001L & xFFFF) as int;
                
                // 10) Add (modulo 0x10000), results of steps 7 and 9.
                t0 = t1 + t0 & xFFFF;
                
                // 11) XOR results from steps 1 and 9.
                x1 = x1 ^ t1;
                
                // 14) XOR results from steps 4 and 10. (Out of order).
                x4 = x4 ^ t0;
                
                // 13) XOR results from steps 2 and 10. (Out of order).
                t0 = t0 ^ x2;
                
                // 12) XOR results from steps 3 and 9. (Out of order).
                x2 = x3 ^ t1;
                
                x3 = t0; // Results of x2 and x3 now swapped.
            }
        
            // Final output transform (4 steps).
            
            // 1) Multiply (modulo 0x10001), 1st text-block
            // with 1st key sub-block.
            x1 = (x1 as long * key.get(iKey++) % x10001L & xFFFF) as int;
            
            // 2) Add (modulo 0x10000), 2nd text sub-block
            // with 2nd key sub-block. It says x3, but that is to undo swap
            // of subblocks 2 and 3 in 8th processing round.
            x3 = x3 + key.get(iKey++) & xFFFF;
            
            // 3) Add (modulo 0x10000), 3rd text sub-block
            // with 3rd key sub-block. It says x2, but that is to undo swap
            // of subblocks 2 and 3 in 8th processing round.
            x2 = x2 + key.get(iKey++) & xFFFF;
            
            // 4) Multiply (modulo 0x10001), 4th text-block
            // with 4th key sub-block.
            x4 = (x4 as long * key.get(iKey++) % x10001L & xFFFF) as int;
            
            // Repackage from 16-bit sub-blocks to 8-bit byte array text2.
            dst.set(iDst++, x1 as byte);
            dst.set(iDst++, (x1 >>> 8) as byte);
            dst.set(iDst++, x3 as byte); // x3 and x2 are switched
            dst.set(iDst++, (x3 >>> 8) as byte); // only in name.
            dst.set(iDst++, x2 as byte);
            dst.set(iDst++, (x2 >>> 8) as byte);
            dst.set(iDst++, x4 as byte);
            dst.set(iDst++, (x4 >>> 8) as byte);
        }
    }
    
    def pure merge(arrays: readwrite Array[readwrite Array[byte]],
            ranges: pure Vector[pure SliceRange]): readwrite Array[byte] {
        val result = new Array[byte](ranges.get(arrays.length - 1).end);
        for(var r = 0; r < ranges.length; r++) {
            val range = ranges.get(r);
            val array = arrays.get(r);
            // access array once to prevent guarding in loop:
            val dummy = array.get(0);
            // apparently, explicitly using a step of 1 helps...
            new Assertion(range.step == 1);
            var j = 0;
            for(var i = range.begin; i < range.end; i++) {
                result.set(i, array.get(j));
                j++;
            }
        }
        return result;
    }
}